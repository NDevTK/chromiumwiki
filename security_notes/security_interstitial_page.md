# SecurityInterstitialPage (`components/security_interstitials/content/security_interstitial_page.h`)

## 1. Summary

`SecurityInterstitialPage` is the abstract base class for all security-related blocking pages shown in Chromium. These pages, known as "interstitials," are displayed when a user navigates to a potentially dangerous resource, such as a site with an invalid SSL certificate, a known phishing or malware page, or other security risks.

This class provides the core framework for creating, displaying, and managing user interaction with these critical warnings. It ensures a consistent user experience and centralizes the logic for handling user decisions (e.g., proceeding to the dangerous site or going back to safety).

## 2. Core Concepts

*   **Interstitial Model:** An interstitial is not a normal webpage. It's a special, locally-generated document that replaces the content of the requested page. It intercepts all user input until the user makes an explicit choice.

*   **Controller-Client Pattern:**
    *   The `SecurityInterstitialPage` is paired with a `SecurityInterstitialControllerClient`.
    *   The `ControllerClient` acts as the "brains" of the operation. It provides the necessary data to populate the interstitial's text and handles the logic for what to do when the user clicks a button (e.g., `GoBack()`, `Proceed()`).

*   **Dynamic HTML Generation:**
    *   The interstitial's content is generated by the `GetHTMLContents()` method.
    *   This method uses a shared HTML template and populates it with strings and data provided by the concrete subclass through the `PopulateInterstitialStrings()` virtual method. This allows for different warnings (SSL, malware, etc.) to share a common look and feel while displaying specific information.

*   **User Commands:**
    *   User interactions on the page (clicking buttons like "Proceed" or "Back to safety") trigger JavaScript functions.
    *   This JavaScript sends a string `command` back to the browser process.
    *   The `CommandReceived()` virtual method is the entry point for the C++ code to handle these commands, typically by delegating to the `ControllerClient`.

## 3. Security-Critical Logic & Responsibilities

The entire class is security-critical. Its primary job is to stand between the user and a potential threat.

*   **Preventing Unsafe Bypass:** The most critical responsibility is to ensure that the user cannot bypass the warning accidentally or be tricked into doing so. The design must be clear, the risks must be accurately communicated, and the "proceed" option must be a deliberate, informed choice.

*   **State Management:** The interstitial hijacks the state of a `WebContents`. A bug in how the interstitial is created, shown, or torn down could lead to state confusion, where the browser's security context is incorrect (e.g., showing a safe URL in the address bar for a dangerous page).

*   **Information Disclosure:** The page must carefully control what information it displays.
    *   `ShouldDisplayURL()`: This method determines whether the URL of the blocked resource should be shown. While usually a good idea for transparency, there could be cases where a misleading URL (e.g., involving homographs) might be hidden to avoid confusing the user further.
    *   The content of the interstitial itself must not introduce new vulnerabilities (e.g., it must not improperly sanitize the hostname it displays, which could lead to UI spoofing).

*   **Command Handling:** The command-handling mechanism must be robust. A flaw could potentially allow the interstitial page's JavaScript to be manipulated to send a command that the user did not intend, such as automatically proceeding to a dangerous site.

## 4. Key Classes and Methods

*   `SecurityInterstitialPage(..., std::unique_ptr<SecurityInterstitialControllerClient> controller)`: The constructor, which takes ownership of the controller that will manage its logic.
*   `virtual void PopulateInterstitialStrings(base::Value::Dict& load_time_data) = 0`: The pure virtual method that subclasses *must* implement to provide the specific text and configuration for their warning.
*   `virtual void OnInterstitialClosing() = 0`: A hook for subclasses to perform cleanup or record final metrics when the user navigates away from the interstitial.
*   `virtual void CommandReceived(const std::string& command)`: Handles string-based commands from the interstitial's JavaScript.

## 5. Related Files

*   `components/security_interstitials/content/security_interstitial_controller_client.cc`: The base implementation for the controller logic.
*   `components/security_interstitials/content/ssl_error_handler.cc`, `safe_browsing/content/browser/threat_details.cc`: Examples of code that *creates* specific types of security interstitials.
*   `components/security_interstitials/core/browser/resources/`: The directory containing the shared HTML, CSS, and JavaScript templates used to build all interstitial pages. Analyzing these files is key to understanding the full front-end logic.